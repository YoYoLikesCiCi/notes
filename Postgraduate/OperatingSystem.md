操作系统 1-2
#第一章 计算机系统概述

## 操作系统的概念

操作系统

是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；

以提供给用户和其他软件方便的接口和环境；

是计算机系统中最基本的系统软件。

## 操作系统的四个特征

### 1\. 并发

指两个或多个事件在同一时间间隔内发生。

这些事件宏观上是同时发生的，微观上是交替发生的。

混淆：并行：指两个或多个事件同时发生

==操作系统的并发性：==指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行的，而微观上看是交替运行的。

操作系统就是伴随着“多道程序技术”而出现的。 因此，操作系统和程序并发是一起诞生的。

注意：

单核CPU同一时刻只能执行一个程序，各个程序只能并发地执行。

多核CPU同一时刻可以同时执行多个程序，多个程序可以并行地执行。

### 2\. 共享

即资源共享，指系统中的资源可供内存中多个并发执行的进程共同使用

$$ 两种资源共享方式：\left \{ \begin{matrix} 互斥共享方式 \\同时共享方式 \end{matrix} \right. $$

### 3\. 虚拟

指把一个物理上的实体变为若干个逻辑上的对应物。

物理实体是实际存在的，而逻辑上对应物是用户感受到的。

### 4\. 异步

在多道程序下，允许多个程序并发执行，但由于资源有限，资源的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。

## 操作系统的目标和功能

$$
1.作为系统资源的管理者 =\left 
\{ 
\begin{matrix}提供的功能 =
\left 
\{ 
\begin{matrix}处理机管理\\存储器管理\\文件管理\\设备管理 
\end{matrix} 
\right. \\ 目标 
\left 
\{ 
\begin{matrix}安全、高效 \\ (教材上）：方便性、有效性、可扩充性、开放性
\end{matrix} 
\right. \end{matrix} \right. 
$$


$$
2.作为用户与计算机硬件系统之间的接口 \left \{ \begin{matrix}命令接口 \left \{ \begin{matrix}GUI \\联机命令接口=交互式命令接口 \\脱机命令接口=批处理命令接口 \end{matrix} \right.\\ 程序接口 \end{matrix} \right.
$$


程序接口：可以在程序中进行系统调用来使用程序接口。

普通用户不能直接使用，只能通过程序代码间接使用。

系统调用又称为 广义调用

3.操作系统用作扩充机器

## 操作系统的发展与分类

### 1\. 手工操作阶段

突出缺点：

1.  用户独占全机，人机速度矛盾导致资源利用率极低
2.  CPU等待手工操作，CPU利用不充分

### 2\. 批处理阶段-单批道处理系统

引入 脱机输入/输出技术，并由监督程序负责控制作业的输入、输出。

主要优点：

缓解了一定程度的人机速度矛盾，资源利用率有所提升。

主要缺点：

内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待I/O完成。资源利用率依然很低。

### 3.批处理阶段-多道批处理系统

主要优点：

- 多道程序并发执行，共享计算机资源。
  
- 资源利用率大幅提升，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。
  

主要缺点：

- 用户响应时间长，
  
- 没有人机交互功能。（无法调适程序/无法在程序中输入一些参数）
  

多道批处理系统需要解决的问题：

1.  处理机争用问题；
2.  内存分配和保护问题；
3.  I/O设备分配问题；
4.  文件的组织和管理问题；
5.  作业管理问题；
6.  用户与系统的接口问题。

### 4\. 分时操作系统

多路性、独立性、及时性、交互性

计算机以 时间片 为单位 轮流为各个用户/作业服务，各个用户可通过终端与计算机进行交互。

人机交互、共享主机。

主要优点：

用户请求可以被即时响应， 解决了人机交互问题。 允许多个用户同时使用一台计算机，并且各个用户对计算机的操作相互独立，感受不到别人的存在。

主要缺点： 不能优先处理一些紧急任务。

操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。

### 5\. 实时操作系统

主要优点： 能够优先响应一些紧急任务，某些紧急任务不需时间片排队。

在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完事件。

实时操作系统的主要特点是及时性和可靠性。

$$
实时操作系统\left \{ \begin{matrix} 硬实时系统 - 必须在绝对严格的规定时间内完成处理 - 如导弹控制系统、自动驾驶系统 \\ 软实时系统- 能接受偶尔违反时间规定 - 如：12306火车订票系统 \end{matrix} \right.
$$

### 6\. 其他几种操作系统

网络操作系统

分布式操作系统

个人计算机操作系统

## 操作系统的运行机制

$$
操作系统的运行机制\left \{ \begin{matrix} 两种指令 \left \{ \begin{matrix} 特权指令\\非特权指令 \end{matrix} \right. \\ 两种处理器状态 \left \{ \begin{matrix} 核心态 \\ 用户态\end{matrix} \right. \\ 两种程序 \left \{ \begin{matrix} 内核程序\\ 应用程序 \end{matrix} \right. \end{matrix} \right.
$$

预备知识：程序是如何运行的？

C语言代码 -> 机器指令（二进制）

### 内核程序 v.s 应用程序

普通程序猿写的就是“应用程序”

微软、苹果有一帮人负责实现操作系统，他们写的是“内核程序”

由很多内核程序组成了“操作系统内核”， 或简称 内核（kernel）

内核是系统中最重要的部分，也是最接近硬件的部分。

操作系统的功能未必都在内核中，如图形化用户界面GUI。

在CPU设计和生产的时候就划分了特权指令和非特权指令，因此CPU执行一条指令前可以判断出其类型。

### 内核态 v.s. 用户态

CPU有两种状态 ： “内核态” 和 “用户态”

处于 内核态 时，说明此时正在运行的是内核程序，此时可以执行特权指令

处于 用户态 时，说明此时正在运行的是应用程序，此时只能执行非特权指令

拓展：CPU中有一个寄存器叫 程序状态字寄存器（PSW）， 其中有个二进制位，1表示“内核态”， 0 表示“用户态”

别名：

内核态 = 核心态 = 管态

用户态 = 目态

![image-20200914144217636](http://picbed.yoyolikescici.cn/uPic/image-20200914144217636.png)

## 中断和异常

### 中断的作用：

中断是让操作系统内核夺回CPU使用权的唯一途径

### 中断的类型：

$$
中断的类型 \left \{ \begin{matrix} 内中断-与当前执行的指令有关，中断信号来源于CPU内部 \left \{ \begin{matrix} 自愿中断--指令中断 \\ 强迫中断 \left \{ \begin{matrix}硬件故障 \\软件中断 \end{matrix} \right. \end{matrix} \right. \\ 外中断-与当前执行的指令无关，中断信号来源于CPU外部 \left \{ \begin{matrix} 外设请求 \\ 人的干预 \end{matrix} \right. \end{matrix} \right. 
$$

$$
中断的类型（王道视频） \left \{ \begin{matrix} 内中断(也称异常、例外) \left \{ \begin{matrix} 陷阱、陷入（trap） --由陷入指令引发，是应用程序故意引发的\\ 故障（fault）--由错误条件引起，可能被内核程序修复。（缺页故障） \\中止（abort）--由知名错误引起，内核程序无法修复。 \end{matrix} \right. \\ 外中断（也称“中断”）\left \{ \begin{matrix} 时钟中断 \\ I/O中断请求 \end{matrix} \right. \end{matrix} \right.
$$



### 中断的基本原理

不同的中断信号，需要用不同的中断处理程序来处理。

当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中的存放位置。

## 系统调用

### 定义：

指用户在程序中调用操作系统所提供的一些子功能，系统调用可视为特殊的公共子程序。

- 设备管理
- 文件管理
- 进程控制
- 进程通信
- 内存管理

凡是与共享资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求，由操作系统内核代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。

### 过程：

传递系统调用参数 -〉 执行陷入指令（用户态） -〉 执行相应的内请求核程序处理系统调用（核心态） 应用程序

1.  陷入指令是在用户态执行的，执行陷入指令之后立即引发一个内中断，使CPU进入核心态
2.  发出系统调用请求是在用户态，而对系统调用的相应处理在核心态下进行。

## 操作系统的体系结构

![image-20200914215657742](http://picbed.yoyolikescici.cn/uPic/image-20200914215657742.png)

内核是操作系统最基本、最核心的部分。

实现操作系统内核功能的那些程序就是内核程序。

![image-20200914215913746](http://picbed.yoyolikescici.cn/uPic/image-20200914215913746.png)

![image-20200914215945924](http://picbed.yoyolikescici.cn/uPic/image-20200914215945924.png)

$$
体系结构\left \{ \begin{matrix} 大内核（典型：Linux，UNIX）\left \{ \begin{matrix}将操作系统的主要功能模块都作为系统内核，运行在核心态\\优点：高性能\\缺点：内核代码庞大，结构混乱，难以维护 \end{matrix} \right.\\ 微内核（典型：Windows NT） \left \{ \begin{matrix}只把最基本的功能保留在内核\\优点：内核功能少，结构清晰，方便维护\\缺点：需要频繁地在核心态和用户态之间切换，性能低 \end{matrix} \right.\end{matrix} \right.
$$


![image-20200924084112528](http://picbed.yoyolikescici.cn/uPic/image-20200924084112528.png)

# 第二章 进程管理

## 进程的概念

程序：是静态的，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。

进程(Process):是动态的，是程序的一次执行过程

当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的“身份证号” \-\- PID（process ID）。

os需要记录PID、进程所属用户ID（UID） --可以让os区分各个进程

还要记录给进程分配了哪些资源（如分配的内存、正在使用的I/O设备、文件） --可用于实现os对资源的管理。

还要记录进程的运行情况（如CPU使用时间、磁盘使用情况、网络流量使用情况） --可用于实现os对进程的控制、调度

这些信息都被保存在一个数据结构==PCB（process control block）==中， 即 进程控制块。

![image-20200924085318170](http://picbed.yoyolikescici.cn/uPic/image-20200924085318170.png)

一个进程实体（进程映像）由PCB、程序段、数据段组成。

进程是动态的，进程实体是静态的。
$$
进程的组成\left \{ \begin{matrix} PCB \left \{ \begin{matrix} 进程描述信息 \\ 进程控制和管理信息 \\ 资源分配清单 \\ 处理机相关信息 \end{matrix} \right. \\程序段 -- 程序的代码（指令序列） \\ 数据段 -- 运行过程中产生的各种数据（如：程序中定义的变量） \end{matrix} \right.
$$




进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

![image-20200924091836398](http://picbed.yoyolikescici.cn/uPic/image-20200924091836398.png)

## 进程的特征

$$进程的特征 \left \{ \begin{matrix} 动态性 --进程是程序的一次执行过程，是动态地产生、变化和消亡的 \\ 并发性 -- 内存中有多个进程实体，各进程可并发执行 \\ 独立性 -- 进程是能独立运行、独立获得资源、独立接受调度的基本单位 \\ 异步性 -- 各进程按各自独立的、不可预知的速度向前推进，os要提供“进程同步机制”来解决异步问题 \\ 结构性 -- 每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成。 \end{matrix} \right.$$

## 进程的状态与转换

$$
 状态与转换 \left \{ \begin{matrix} 状态 \left \{ \begin{matrix} 运行状态 -- 占有CPU，并在CPU上运行\\ 就绪状态 -- 已经具备运行条件，但由于没有空闲CPU，而暂时不能运行 \\ 阻塞状态 -- 因等待某一时间而暂时不能运行 \\ 创建状态 -- 进程正在被创建，os为进程分配资源、初始化PCB \\终止状态 -- 进程正在从系统中撤销，os会回收进程拥有的资源、撤销PCB \end{matrix} \right. \\状态间的转换 \left \{ \begin{matrix} 就绪态 -> 运行态 \\ 运行态 -> 就绪态 \\ 运行态-> 阻塞态 \\阻塞态 -> 就绪态 \end{matrix} \right. \\ 进程的组织方式（各进程PCB的组织方式） \end{matrix} \right.
$$



一个进程可以执行exit 系统调用，请求os终止该进程。

此时该进程会进入“终止态”， os会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB。

![image-20200924124501994](http://picbed.yoyolikescici.cn/uPic/image-20200924124501994.png)

### 进程的组织 \- 链接方式

![image-20200924125146237](http://picbed.yoyolikescici.cn/uPic/image-20200924125146237.png)

### 进程的组织 \- 索引方式（简要了解）

![image-20200924125241840](http://picbed.yoyolikescici.cn/uPic/image-20200924125241840.png)

## 进程控制

如何：

原语：是一种特殊的程序，它的执行具有原子性。 这段程序的运行必须一气呵成，不可中断。

可以用“关中断指令”和“开中断指令” 这两个特权指令实现原子性。

正常情况：CPU每执行完一条指令都会例行检查是否有中断信号需要处理，如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。

执行完关中断后：不再例行检查中断信号，直到执行开中断指令之后才会恢复检查。

### 进程控制相关的原语

$$
进程的创建 \left \{ \begin{matrix} 创建原语\left \{ \begin{matrix} 申请空白PCB \\ 为新进程分配所需资源 \\ 初始化 PCB \\将PCB插入就绪队列 \end{matrix} \right. \\ 引起进程创建的事件 \left \{ \begin{matrix} 用户登录--分时系统中，用户登录成功，系统会为其建立一个新的进程 \\ 作业调度 -- 多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程 \\ 提供服务 -- 用户向os提升某些请求时，会新建一个进程处理该请求 \\ 应用请求 -- 由用户进程主动请求创建一个子进程 \end{matrix} \right. \end{matrix} \right. 
$$

$$
进程的终止\left \{ \begin{matrix} 撤销原语 \left \{ \begin{matrix} 从PCB集合中找到终止进程的PCB \\ 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程 \\终止其所有子进程 \\ 将该进程拥有的所有资源归还给父进程或os \\ 删除PCB \end{matrix} \right. \\ 引起进程终止的事件 \left \{ \begin{matrix} 正常结束 \\ 异常结束\\ 外界干预 \end{matrix} \right. \end{matrix} \right. 
$$

$$
进程的阻塞\left \{ \begin{matrix} 阻塞原语 \left \{ \begin{matrix} 找到要阻塞的进程对应的PCB \\ 保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行 \\将PCB插入相应事件的等待队列 \end{matrix} \right.\\引起进程阻塞的事件 \left \{ \begin{matrix} 需要等待系统分配某种资源 \\ 需要等待相互合作的其他进程完成工作 \end{matrix} \right. \end{matrix} \right. 
$$

$$
进程的阻塞唤醒\left \{ \begin{matrix} 唤醒原语 \left \{ \begin{matrix} 在事件等待队列中找到PCB \\将PCB从等待队列移除，设置进程为就绪态 \\将PCB插入就绪队列，等待被调度 \end{matrix} \right.\\引起进程唤醒的事件 \left \{ \begin{matrix} 等待的事情发生 \end{matrix} \right. \end{matrix} \right.
$$



### 程序是如何运行的

![image-20200924134538587](http://picbed.yoyolikescici.cn/uPic/image-20200924134538587.png)

## 进程通信

$$
进程通信\left \{ \begin{matrix} 共享存储 \left \{ \begin{matrix} 基于数据结构的共享 \\ 基于存储区的共享 \end{matrix} \right.\\ 消息传递 \left \{ \begin{matrix} 直接通信方式 \\ 间接通信方式 \end{matrix} \right. \\ 管道通信 \end{matrix} \right.
$$

进程通信：进程之间的信息交换

进程是分配系统资源的单位（包括内存地址空间），因此各进程拥有的内存地址空间相互独立。

为了保证安全， 一个进程不能直接访问另一个进程的地址空间。

### 1\. 共享存储

分配一个共享空间，两个进程对共享空间的 **访问** 必须是 **互斥** 的。

基于**数据结构**的共享： 比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种低级通信的方式。

基于 **存储区** 的共享：在内存中划出一块共享存储区，数据的形式、存放位置都由进程控制，而不是操作系统。 相比之下，这种共享方式速度更快，是一种高级通信的方式。

### 2\. 管道通信

管道： 指用于连接读写进程的一个共享文件，又名 pipe 文件。

其实就是在内存中开辟一个大小固定的缓冲区。

![image-20200924190242095](http://picbed.yoyolikescici.cn/uPic/image-20200924190242095-20200924190535688.png)

1.  管道只能采用半双工通信，如果要实现双向同时通信，则需要设置两个管道。
2.  各进程要互斥地访问管道。
3.  数据以字符流的形式写入管道，当管道写满时，写进程的wirte()系统调用将被阻塞，等待读进程将数据取走。当读进程将数据全部取走后，管道变空，此时读进程的read()系统调用将被阻塞。
4.  如果 没写满，就不允许读。 如果没读空，就不允许写。
5.  数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能由一个，否则可能会有读错数据的情侣。

### 3\. 消息传递

进程间的数据以 =格式化的消息（message）为单位。通过os提供的“发送消息/接收消息”两个原语进行数据交换。

![image-20200924191828492](http://picbed.yoyolikescici.cn/uPic/image-20200924191828492.png)

## 线程的概念，多线程模型

引入原因： 有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。

可以把线程理解为“轻量级进程”

线程是一个基本的CPU执行单元，也是程序执行流的最小单位。

引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度。

引入线程后，进程只作为除CPU之外的系统资源的分配单元。

$$
线程的属性 \left \{ \begin{matrix} 线程时处理机调度的单位 \\ 多CPU计算机中，各个线程可占用不同的CPU \\每个线程都有一个线程ID、线程控制块TCB \\线程也有就绪、阻塞、运行三种基本状态 \\ 线程几乎不拥有系统资源 \\ 同一进程的不同线程间共享进程的资源 \\由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预 \\ 同一进程中的线程切换，不会引起进程切换 \\不同进程中的线程切换，会引起进程切换 \\切换同进程内的线程，系统开销很小 \\ 切换进程，系统开销较大 \end{matrix} \right.
$$


## 线程的实现方式

$$
线程\left \{ \begin{matrix} 线程的实现方式 \left \{ \begin{matrix} 用户级线程 \\内核级线程 \end{matrix} \right.\\ 多线程模型 \left \{ \begin{matrix} 一对一模型 \\多对一模型 \\多对多模型 \end{matrix} \right.\end{matrix} \right.
$$

### 1\. 用户级线程 (user-Level Thread, ULT) -由线程库实现

![image-20200925123417886](http://picbed.yoyolikescici.cn/uPic/image-20200925123417886.png)

1、 线程的管理工作由谁来完成

由应用程序通过线程库来完成

#### 优点

用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

#### 缺点：

当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。

### 2\. 内核级线程(Kernel-Level Thread, KLT )--由操作系统支持的线程

![image-20200925125824490](http://picbed.yoyolikescici.cn/uPic/image-20200925125824490.png)

#### 优点：

当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。

#### 缺点：

一个用户进程会占用多核内核级线程，线程切换由os内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

### 一对一模型

![image-20200925130112738](http://picbed.yoyolikescici.cn/uPic/image-20200925130112738.png)

一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。

#### 优点：

当一个线程被阻塞后，别的进程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。

#### 缺点：

一个用户进程会占用doge内核级线程，线程切换由os内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

### 多对一模型

![image-20200925130251746](http://picbed.yoyolikescici.cn/uPic/image-20200925130251746.png)

多个用户级线程映射到一个内核级线程。且一个进程植被分配一个内核级线程。

#### 优点：

用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高。

#### 缺点：

当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。

### 多对多模型

n用户及线程映射到m个内核级线程（n>=m)。每个进程对应m个内核级线程。

克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

![image-20200925130334822](http://picbed.yoyolikescici.cn/uPic/image-20200925130334822.png)

用户级线程是“代码逻辑”的载体

内核级线程是“运行机会”的载体。

## 处理机调度-概念、层次

### 1\. 高级调度 - 作业调度

作业：一个具体的任务

用户向os提交一个作业 ～～ 用户让os启动一个程序

高级调度：按一定的原则从外存的作业后备队列中挑选一个作业调入内粗，并创建进程。==每个作业只掉入一次，调出一次。作业调入时会创建PCB，调出时才撤销PCB。

### 2\. 低级调度-进程调度/处理机调度

按照某种策略从就绪队列中选取一个进程，将处理机分配给它。

进程调度是os中最基本的一种调度，在一般的os中都必须配置进程调度。

进程调度的频率最高，一般几十毫秒一次。

### 3\. 中级调度 - 内存调度

按照某种策略决定将哪个处于挂起状态的进程重新调入内存。

内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。

暂时调到外存等待的进程状态为挂起状态。 被挂起的进程PCB会被组织成挂起队列。

### 4\. 进程的挂起态

暂时调到外存等待的进程状态为挂起状态（挂起态， suspend）

挂起态又可进一步细分为就绪挂起、阻塞挂起两种状态。

### 5\. 七状态模型

![image-20200925142030740](http://picbed.yoyolikescici.cn/uPic/image-20200925142030740.png)

### 6\. 三层调度的联系、对比

![image-20200925142123720](http://picbed.yoyolikescici.cn/uPic/image-20200925142123720.png)

## 进程调度的 时机、切换与过程、方式

$$
需要进行进程调度的情况\left \{ \begin{matrix} 当前运行的进程主动放弃处理机 \left \{ \begin{matrix} 进程正常终止 \\运行过程中发生异常而终止 \\ 进程主动请求阻塞 （如等待I/O） \end{matrix} \right. \\ 当前运行的进程被动放弃处理机 \left \{ \begin{matrix} 分配的时间片用完 \\ 有更紧急的事需要处理（如I/O中断） \\ 由更高优先级的继承进入就绪队列 \end{matrix} \right.\end{matrix} \right. 
$$

$$
不能进行进程调度与切换的情况\left \{ \begin{matrix}在处理中断的过程中。\\进程在os内核程序临界区中 \\ 在原子操作过程（原语）中 \end{matrix} \right.
$$



临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥的访问临界资源。

临界区：访问临界资源的代码

内核程序临界区：一般是用来访问某种内核数据结构的，比如进程的就绪队列。

只有操作系统内核临界区不能进行进程调度，普通的临界区可以

### 进程调度的方式

1.  非剥夺调度方式

又称非抢占方式。

只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进去阻塞态。

实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。

2.  剥夺调度方式

又称 抢占方式。 当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。

可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时os、实时os。

### “狭义的进程调度” 与 “进程切换”的区别

“狭义的进程调度”指的是从就绪队列中选中一个要运行的进程。（这个进程可以时刚刚被暂停执行的进程，也可能是另一个进程，后一种情况就需要进程切换。）

进程切换是指一个进程让出处理机，由另一个进程占用处理机的过程。

广义的进程调度包含了选择一个进程和进程切换两个步骤。

进程切换的过程主要完成了：

1.  对原来运行进程各种数据的保存
2.  对新的进程各种数据的恢复

注意：进程切换是有代价的，因此如果 过于频繁的进行进程调度、切换，必然会使整个 系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行过程的时间减少。

## 调度算法的评价指标

$$
指标\left \{ \begin{matrix} CPU利用率 \\ 系统吞吐量 \\ 周转时间\left \{ \begin{matrix}周转时间、平均周转时间 \\ 带权周转时间、平均带权周转时间 \end{matrix} \right. \\ 等待时间 \\ 响应时间\end{matrix} \right.
$$



CPU利用率：指CPU“忙碌”的时间占总时间的比例

系统吞吐量：单位时间内完成作业的数量

周转时间：指从作业被提交给系统开始，到作业完成为止 的这段时间间隔。

包括四个部分：

作业从外存后备队列上等待作业调度（高级调度）的时间

进程在就绪队列上等待进程调度（低级调度）的时间

进程在CPU上执行的时间

进程等待I/O操作完成的时间

后三项在一个作业的整个处理过程中，可能发生多次。

平均周转时间： 各作业周转时间之和/作业数

带权周转时间 ： $$=\frac{作业周转时间}{作业实际运行的时间} = \frac{作业完成时间-作业提交时间}{作业实际运行的时间}$$

带权周转时间 必然 $$\geq$$ 1

带权周转时间与周转时间都是越小越好

等待时间，指进程/作业处于等待处理机状态时间之和 ，等待时间越长，用户满意度越大。等待时间越长，用户满意度越低。

对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。

响应时间：指从用户提交请求到首次产生响应所用的时间。

## 调度算法

学习思路：

1 算法思想

2 算法规则

3 用于作业调度还是进程调度

4 抢占式， 非抢占式

5 优点和缺点

6 是否会导致饥饿 ----某进程/作业长期得不到服务

### 1\. 先来先服务（FCFS）

$$
FCFS \left \{ \begin{matrix} 算法思想 -- 主要从”公平“的角度考虑 \\ 算法规则 -- 按照作业/进程到达的先后顺序进行服务 \\ 用于作业/进程调度 -- 用于作业调度时，考虑的是那个作业先到达后备队列； 用于进程调度时，考虑的是那个进程先到达就绪队列 \\ 是否可抢占 -- 非抢占式的算法 优缺点 \left \{ \begin{matrix}优点：公平、算法实现简单 \\ 缺点：排在唱作业后面的短作业需要等待很长时间，带权周转时间很大的，对短作业来说用户体验不好 \\FCFS对长作业有利，对短作业不利 （eg：排队买奶茶） \end{matrix} \right.\\是否会导致饥饿 -- 不会 \end{matrix} \right.
$$





![image-20200925152544474](http://picbed.yoyolikescici.cn/uPic/image-20200925152544474.png)

### 2\. 短作业优先（SJF， shortest job first）

$$
SJF\left \{ \begin{matrix} 算法思想 -- 追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间 \\ 算法规则 -- 最短的作业/进程优先得到服务（要求服务时间最短） \\ 用于作业/进程调度 -- 两个都可以，用于进程时称为“短进程优先” （spf） \\ 是否可抢占 -- 非抢占式， 也有抢占式版本：最短剩余时间优先算法(SRTN,Shortest \quad Remaining \quad Time \quad Next) \\优缺点 \left \{ \begin{matrix} 优点：“最短的平均等待时间、平均周转时间” \\缺点 ：不公平。 对短作业有利，对唱作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先\end{matrix} \right. \\ 是否会导致饥饿--会。如果源源不断地有短作业、进程到来，可能使唱作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死” \end{matrix} \right.
$$



![image-20200925153822185](http://picbed.yoyolikescici.cn/uPic/image-20200925153822185.png)

![image-20200925155234901](http://picbed.yoyolikescici.cn/uPic/image-20200925155234901.png)

### 3\. 高响应比优先 (HRRN, highest response ratio next)

$$
HRRN\left \{ \begin{matrix} 算法思想 -- 要综合考虑作业/进程的等待时间和要求服务的时间 \\ 算法规则 -- 在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务 . 响应比= \frac{等待时间+要求服务时间}{要求服务时间} \geq 1\\ 用于作业/进程调度--都可以 \\ 是否可以抢占 -- 非抢占式的算法。只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比 \\ 优缺点：\left \{ \begin{matrix} 优点：综合考虑了等待时间和运行时间 ，对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题 \\ \end{matrix} \right. \\是否会导致饥饿-- 不会\end{matrix} \right.
$$



![image-20200925163025387](http://picbed.yoyolikescici.cn/uPic/image-20200925163025387.png)

![image-20200925163406569](http://picbed.yoyolikescici.cn/uPic/image-20200925163406569.png)

### 4\. 时间片轮转

$$
时间片轮转\left \{ \begin{matrix} 算法思想 -- 公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应 \\ 算法规则 -- 按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。 \\ 用于作业/进程调度-- 用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）\\ 是否可以抢占 -- 若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法，由时钟装置发出时钟中断来通知CPU时间片已到 \\ 优缺点：\left \{ \begin{matrix} 优点：公平，响应快，适用于分时os \\缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度 \end{matrix} \right. \\是否会导致饥饿-- 不会 \\补充 -- 时间片太大或者太小会有什么影响\end{matrix} \right.
$$



如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。

### 5\. 优先级调度算法

$$
优先级调度算法\left \{ \begin{matrix} 算法思想 -- 随着计算机的发展，特别是实时os的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序 \\ 算法规则 -- 每个作业/进程有个字的优先级，调度时选择优先级最高的作业/进程 \\ 用于作业/进程调度--都可以，甚至还可以用于I/O调度中 \\ 是否可以抢占 -- 都有，非只需进程主动放弃时进行调度即可，抢则需要在就绪队列变化时，检查是否会发生抢占 \\ 优缺点：\left \{ \begin{matrix} 优点：用优先级区分紧急程度、重要程度，适用于实时os。可灵活地调整对各种作业/进程的偏好程度 \\缺点：若源源不断地有高优先级进程到来，则可能导致饥饿 \end{matrix} \right. \\是否会导致饥饿-- 会\end{matrix} \right.
$$



补充：

就绪队列未必只有一个，可以按照不同优先级来租住。

另外，也可以把优先级高的进程排在更靠近队头的位置。

根据优先级是否可以动态改变，可以将优先级分为 动态优先级和静态优先级。

通常：

系统进程优先级高于用户进程

前台进程优先级高于后台进程

os更偏好I/O型进程（与之相对的是计算型进程）

when调整优先级：

- 从追求公平、提升资源利用率等角度考虑
  
    - 如果某进程在就绪队列中等待了很长时间，则可适当降低其优先级
      
    - 如果某进程占用处理机运行了很长时间，则可适当降低其优先级
      
    - 如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级
      

例题：

![image-20200928125111744](http://picbed.yoyolikescici.cn/uPic/image-20200928125111744.png)

![image-20200928130831132](http://picbed.yoyolikescici.cn/uPic/image-20200928130831132.png)

### 6.多级反馈队列调度算法

$$
多级反馈队列\left \{ \begin{matrix}算法思想 -- 对其他调度算法的这种权衡 \\ 算法规则 \left \{ \begin{matrix}1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大 \\ 2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。\\如果此时已经是在最下级的队列，则重新放回该队列队尾 \\ 3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片 \end{matrix} \right.\\ 用于作业/进程调度 -- 用于进程调度 \\ 是否可以抢占-- 抢占式。\\优缺点：\left \{ \begin{matrix} 优点：\left \{ \begin{matrix} 对各类型进程相对公平（FCFS的优点）\\ 每个新到达的进程都可以很快就得到响应（rr的优点） \\ 短进程只用较少的时间就可完成（SPF的优点） \\ 不必实现估计进程的运行时间（避免用户作假）；\\可灵活地调整各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程 \end{matrix} \right. \end{matrix} \right.是否会导致饥饿 -- 会 \end{matrix} \right.
$$



### 7\. 总结：

![image-20200928135205157](http://picbed.yoyolikescici.cn/uPic/image-20200928135205157.png)

## 进程同步、进程互斥

### 同步：

也称直接制约关系，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。

### 互斥：

一个时间段内只允许一个进程使用的资源称为临界资源。

对临界资源的访问，必须互斥地进行。

互斥，又叫 间接制约关系。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。

![image-20200928211314933](http://picbed.yoyolikescici.cn/uPic/image-20200928211314933.png)

### 进程互斥原则：

1.  空闲让进。
  
    临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。
    
2.  忙则等待。
  
    当已有进程进入临界区时，其他试图进入临界区的进程必须等待。
    
3.  有限等待。
  
    对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）
    
4.  让权等待。
  
    当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。
    

## 进程互斥的软件实现方法

### 1\. 单标志法

#### 算法思想：

两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。

也就是说每个进程进入临界区的权限只能被另一个进程赋予。

![image-20200929135804819](http://picbed.yoyolikescici.cn/uPic/image-20200929135804819.png)

缺点：违背 “空闲让进”原则

### 2\. 双标志先检查（以及后检查）法

#### 算法思想：

设置一个布尔型数组flag\[\],数组中各个元素用来标记个进程想进入临界区的意愿，比如 “flag\[0\] = ture"意味着0号进程p0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则吧自身对应的标志flag\[i\]设为true，之后开始访问临界区。

![image-20200929141001204](http://picbed.yoyolikescici.cn/uPic/image-20200929141001204.png)

#### 缺点： 先检查违反“忙则等待”原则

原因在于 ，进入区的“检查”和“上锁”两个处理不是一气呵成的。“检查”后、“上锁”前 可能发生进程切换后检查违反“空闲让进、有则等待”原则，有可能导致“饥饿”

### 3\. peterson算法

#### 算法思想：结合双标志法、单标志法的思想。

都想进，用“孔融让梨”

![image-20200929142253276](http://picbed.yoyolikescici.cn/uPic/image-20200929142253276.png)

#### 缺点：

没有遵循 让权等待 原则

## 进程互斥的硬件实现方法

### 1\. 中断屏蔽方法

利用“开/关中断指令”实现

关中断后不允许当前进程被中断

优点：简单、高效

缺点：不适用于多处理机；

只适用于os内核进程，不适用于用户进程（因为这指令只能运行在内核态）

### 2\. TestAndSet指令

简称 TS指令，也有地方称为 TestAndSetLock指令，或TSL指令

此指令是用硬件实现的，执行的过程中不允许被中断，只能一气呵成。

![image-20200929143301175](http://picbed.yoyolikescici.cn/uPic/image-20200929143301175.png)

#### 优点：

实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境

#### 缺点：

不满足“让权等待”原则

### 3\. Swap 指令

有的地方也叫Exchange指令，或简称 XCHG指令。

Swap指令 是用硬件实现的，执行的过程不允许被中断，只能一气呵成。

![image-20200929143741080](http://picbed.yoyolikescici.cn/uPic/image-20200929143741080.png)

## 信号量机制

用户进程可以通过使用os提供的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步

信号量其实就是一个变量，可以用一个信号量来表示os中某种资源的数量。

原语是一种特殊的程序段，其执行只能一气呵成，不可被中断。。

原语是由关中断/开中断指令实现的。

一对原语：

Wait(S) 和 Signal(S).

分别称为p操作，v操作， 可写成 P(S), V(S)

### 整型信号量

使用一个整数型的变量作为信号量，用的表示系统中某种资源的数量。

不满足“让权等待”，会发生“忙等”

```C++
int S = 1; //初始化整型信号量S，表示当前系统中可用的打印机资源数

void wait (int S) {  //wait原语，相当于“进入区”
    while (S<=0);  //如果资源数不够，就一直等待
    S = S - 1;  //如果资源数够，则占用一个资源
}

void signal (int S){  //signal 原语，相当于“退出区”
    S = s + 1;    //使用完资源后，在退出区释放资源
}

进程P0:
……
wait(S);
使用打印机资源;
signal(S);
```

### 记录型信号量

用记录型数据结构表示的信号量

```C++
typedef struct{
    int value;  //剩余资源数
    struct process *L;    //等待队列
}semaphore;

void wait(semaphore S){
    S.value--;
    if (S.value < 0 ){  //如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并挂到信号量S的等待队列（即阻塞队列）中
        block (S.L); 
    }
}

void signal(semphore S){
    S.value++;
    if (S.value <= 0){  //释放资源后，如果还有别的进程，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
        wakeup(S.L);
    }
}
```

## 用信号量机制实现进程互斥、进程同步、进程前驱关系

### 1\. 进程互斥

1.  分析并发进程的关键活动，划定临界区
  
2.  设置互斥信号量mutex，初值为1
  
3.  在进入区P（mutex） -- 申请资源
  
4.  在退出区V（mutex） -- 释放资源
  
    ```C++
    semaphore mutex = 1;
    
    P1(){
         ...
         P(mutex);
        临界代码;
        V(mutex);
        ...
    }
    
    P2(){
         ...
         P(mutex);
        临界代码;
        V(mutex);
        ...
    }
    
    ```

注意：

对不同的临界资源需要设置不同的互斥信号量

P\\V操作必须成对出现。

缺少P就不能保证临界资源的互斥访问。

缺少V会导致资源永不被释放，等待进程永不被幻想。

### 2\. 进程同步

1.  分析什么地方需要实现“同步关系”， 即必须保证“一前一后”执行的两个操作
2.  设置同步信号量S，初始为0
3.  在“前操作”之后执行V（S）
4.  在“后操作”之前执行P（S）

![image-20200929170736719](http://picbed.yoyolikescici.cn/uPic/image-20200929170736719.png)

### 3\. 前驱关系

![image-20200929171118907](http://picbed.yoyolikescici.cn/uPic/image-20200929171118907.png)

# 第二章实际应用

## 生善者消费者问题

问题：

系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。

生产者、消费者共享一个初始为空、大小为m的缓冲区。

只有缓冲区没满时，消费者才能从中取出产品，否则必须等待。

缓冲区是临界资源，各进程必须互斥地访问。

# 总结：

$$
\left \{ \begin{matrix}进程管理 \left \{ \begin{matrix} \end{matrix} \right.\end{matrix} \right.

$$

